  subroutine allocate_mascon_arrays

! subroutine to allocate the mascon arrays. It uses different memory to dimension them dynamically
! than to dimension them in the mascon_mod.f90 file, so I'm doing it this way. It also speeds up
! the compilation time for the programs .....
!
! P. Tregoning
! 9 September 2016
!
! MODS

  use mascon_mod

  implicit none

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                           !!
!!   A L L O C A T E    T H E    M A S C O N    A R R A Y S  !!
!!                                                           !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! primary mascon variables
! PT161028: added tidal amplitude flag as an extra column to mcon_prim
  allocate(mcon_prim(max_prim,11))    ! primary mascon info (lat/lon/rad/area/hgt/density/#sec/#tern/#first secondary/tidal flag/%land)
  allocate(mcon_EWH(max_prim))        ! EWH a priori value for each mascon
  allocate(mcon_region(max_prim))     ! region character code for each primary mascon
  allocate(prim_flags(max_prim))      ! 6-char flags for type of mascon (PDeep/PShelf etc)

! secondary
  allocate(mcon_sec(max_prim,max_sec_per_prim,8))    ! secondary info ( lat/lon/rad/area/hgt/density/sec_number/#terns in this secondary )
  allocate(mcon_sec_ptr(max_sec))                    ! pointer to primary mascon in which this secondary resides
  allocate(sec_colour(max_sec))                      ! colour of primary mascon in which this secondary resides
  allocate(sec_flags(max_sec))                       ! 6-char flags for type of mascon (PDeep/PShelf etc)

! ternary
! PT161028: added tidal amplitude flag as an extra column to mcon_tern
  allocate(mcon_tern(max_prim,max_tern_per_prim,8))  ! ternary info ( lat/lon/rad/area/hgt/density/sec_number/#terns in this secondary/tidal flag of primary/ ) 
  allocate(mcon_tern_ptr(max_tern,2))
  allocate(tern_colours(max_tern,2))                 ! colour of primary and secondary mascon in which this ternary resides
  allocate(tern_flag(max_tern))                      ! 6-char flags for type of ternary mascon (PDeep/PShelf etc)

! the arrays used to compute the accelerations from the vector list of mascons per epoch
  allocate(mcon_xyz(3,800 * max_prim))    ! XYZ Efixed coordinates (m)
  allocate(mcon_area(800 * max_prim))     ! mascon areas (sq. m.)
  allocate(mcon_num(max_prim))            ! mass con counter for gravity & partials
  allocate(mcon_rho(800* max_prim))       ! density of the mascons in the list 

!!! OCEAN MASCONS
! primary ocean mascons
  allocate(mcon_ocean_prim(max_ocean_prim,2))         ! primary ocean info (lat/lon/rad/area/hgt/#tern/bit-mapped tide
! ternary
  allocate(mcon_ocean_tern(max_tern,7))       ! ocean ternary info (lat/lon/rad/area/hgt/density/bit-mapped-tide/????
  allocate(mcon_ocean_tern_ptr(max_tern,2))   ! pointer to ocean primary mascons in which the ocean ternary resides

! set the pointer values to zero
  mcon_ocean_tern_ptr = 0

  return
  end
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine read_msc_hdr(lumsc,msc_file,hdr_lines,max_hdr_lines,n_hdr_lines,msc_file_code,nprim,nsec,ntern &
                                ,tern_per_prim,tern_per_sec,sec_per_prim)

! subroutine to open the mascon file and read in the header information.
! It needs to be able to work for either temporal gravity mascons or
! ocean mascons
!
! P. Tregoning
! 4 November 2016

  implicit none

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! passed variables
  integer,       intent(in)    :: max_hdr_lines              ! dimensioning of hdr_lines array     
  character*150, intent(inout) :: hdr_lines(max_hdr_lines)   ! vector of header lines in the mascon file
  integer,       intent(in)    :: lumsc                      ! unit number of mascon file to be opened and read
  character*150, intent(in)    :: msc_file                   ! name of mascon file
  integer*4,     intent(out)   :: n_hdr_lines                ! actual number of header lines found in the mascon file   
  character*8,   intent(out)   :: msc_file_code              ! 8-character file code for mascon file
  integer*4,     intent(out)   :: nprim,nsec,ntern           ! number of ternary, secondary, primary mascons in the file
  integer*4,     intent(out)   :: tern_per_prim,tern_per_sec,sec_per_prim ! max number of tern/sec per other type of mascon

! local variables
  integer*4      :: ioerr
  character*150  :: message
  logical        :: hdr_line
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! open the mascon file
  open (unit=lumsc, file=msc_file, status='old',iostat=ioerr)
  if(ioerr /= 0)then
    call report_stat('FATAL','LIB','read_msc_hdr',msc_file,'Error opening mascon file. Does it exist?',0)
  else
    call report_stat('STATUS','LIB','read_msc_hdr',msc_file,'Reading mascon information',0)
  endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! read the first header line. It contains the mascon file code and the 
! information on the number of primary/secondary/ternary mascons etc
  n_hdr_lines = 1
  read(lumsc,'(a)')hdr_lines(n_hdr_lines)

  ! extract out the mascon file code and the values on the line
  msc_file_code = hdr_lines(1)(1:8)
  read(hdr_lines(1)(9:100),*)nprim,nsec,ntern,sec_per_prim,tern_per_prim,tern_per_sec
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! read, store and count the reamining header lines
  hdr_line = .true.
  do while (hdr_line)
    n_hdr_lines = n_hdr_lines + 1
    read(lumsc,'(a)')hdr_lines(n_hdr_lines)
    if(hdr_lines(n_hdr_lines)(1:1) /= "#")then
      hdr_line = .false.
      n_hdr_lines = n_hdr_lines - 1
      backspace(lumsc)
    else
      call report_stat('STATUS','LIB','read_msc_hdr',' ',hdr_lines(n_hdr_lines),0)
    endif
  enddo

  write(message,'(a,i5,a)')"Read ",n_hdr_lines," header lines from input mascon file"
  call report_stat('STATUS','LIB','read_msc_hdr',msc_file,message,0)

  return
  end subroutine read_msc_hdr
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tern_lat_bands(lat_spacing)

! subroutine to establish how many ternary latituide bands and how many ternary mascons per band
!
! P. Tregoning
! 3 September 2016

  use mascon_mod

  implicit none

  real(kind=8) :: lat_spacing     ! separation of ternary mascons (in decimal degrees)
  integer*4    :: points_per_degree
  real(kind=8) :: colat
  integer*4    :: i,num_long,total_nterns
  real(kind=8) :: del_long
  real(kind=8) :: pi,rad_fact
  character*100 :: message

  pi = 4.0*atan(1.0)
  rad_fact = pi/180.


! work out the number of latitudinal bands
  n_tern_lat_bands = int(180.e0/lat_spacing) + 1
  points_per_degree = nint(1.e0/lat_spacing)

  write(message,'(a,f20.17,a,i8)')"  Ternary latitude spacing (degrees):",lat_spacing,' Number of bands: ',n_tern_lat_bands
  call report_stat ('STATUS','LIB','tern_lat_bands',' ',message,0)
  
! allocate the latitude bands array
  allocate(nterns_per_band(n_tern_lat_bands))

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! loop through the latitiude bands and work out how manny ternary  !!
! mascons in each
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  total_nterns = 0
  do i = 1, n_tern_lat_bands
    colat = dble(i - 1)/points_per_degree
    if ( ( i .eq. 1 ) .or. ( i .eq. n_tern_lat_bands ) ) then
      nterns_per_band(i) = 1
    else
      del_long = 180./(float(n_tern_lat_bands - 1) * sin(colat * rad_fact))
      nterns_per_band(i) = idint(360./del_long)
    endif
    total_nterns = total_nterns + nterns_per_band(i)
  enddo

  write(message,'(a,i10,a)')'  There are a total of ',total_nterns,' ternary mascons'
  call report_stat ('STATUS','LIB','tern_lat_bands',' ',message,0)

  return

  end subroutine tern_lat_bands
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine calc_which_ternary(debug,lat,lon,tern_spacing,tern_number)

! subroutine to work out the ternary number, given a lat/lon
!
! P. Tregoning
! 2 September 2016

  use mascon_mod

  implicit none

! passed variables
  logical     , intent(in)  :: debug            ! flag to output debug 
  real(kind=8), intent(in)  :: lat, lon         ! coords of the requested point
  real(kind=8), intent(in)  :: tern_spacing     ! latitudinal width (in dec. degrees) of the ternary mascons
  integer*4,    intent(out) :: tern_number

! other variables
  real(kind=8) :: long_width
  integer*4    :: lat_band,num_long
  character    :: message*200
  real(kind=8) :: pi

  pi = 4.d0*datan(1.d0)

  if(debug)print*,'DEBUG: calc_which_ternary lat, lon, tern_spacing',lat,lon,tern_spacing

! PT161025: add a trap to ensure that latitude - and not co-latitude - is passed in for satellite location
  if(lat > 90.d0)then
    write(message,'(a,2f8.4,a)')"Methinks that co-latitude has been provided. It must be latitude (lat,lon: " &
                                ,lat,lon,")"
    call report_stat('FATAL','LIB','calc_which_ternary',' ',message,0)
  endif

! from the latitude, we can work out which ternary latitude band the point is in
  lat_band = nint((90.d0-lat)/tern_spacing)+1
  if(debug)print*,"DEBUG: colat,spacing,real(colat/spacing)" &
           ,(90.d0-lat),tern_spacing,(90.d0-lat)/tern_spacing,nint((90.d0-lat)/tern_spacing)+1
!  if(mod((90.-lat)/tern_spacing, 1.) /= 0. .or. lat == 90.)lat_band = lat_band + 1
! now, from the longitude we can work out how many to wrap around
  long_width = 360./dble(nterns_per_band(lat_band))
  num_long = nint(lon/long_width)

! therefore, work out the ternary mascon number
  tern_number = sum(nterns_per_band(1:lat_band-1)) + num_long + 1

  if(debug)then
    print*,'DEBUG: latitude band:',lat_band,' of',n_tern_lat_bands,' bands.'
    print*,'DEBUG: ternary is number ',num_long,' mascon on the latitude band'
    print*,'DEBUG: ternary number is',tern_number
  endif

! PT161201: rescale the computed value to account for the difference between Herb's and my calculations
!  tern_number = nint(dble(tern_number)/1484568.d0 * 5076) + tern_number
!  if(lat > 0.)then
!    tern_number = tern_number + nint(dsin(lat*pi/180.)*5076.0/2.0)
!  else
!    tern_number = tern_number + 5076./2.0 - nint(dsin((90.+lat)*pi/180.)*5076./2.0)
!  endif

  return
  end subroutine calc_which_ternary
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine read_mascon_file(luin,mascon_file)

! subroutine to read the primary, secondary and ternary mascon information from 
! the new, single file that contains all information. This replaces the code
! that was in graceorb.f90, which read several different files
!
! P. Tregoning
! 5 September 2016

! MODS
! PT161028: added the bit-mapped tidal amplitude information to the mcon_prim array
! PT161104: mascon file now opened in subroutine read_mascon_header

  use  mascon_mod

  implicit none

  integer*4, intent(in)     :: luin              ! unit number of mascon file (=21)
  character*150,intent(in)  :: mascon_file

! primary mascon variables
  integer*4    :: num_mcon                       ! running count of how many primary mascons in mascon_file
  character*6  :: tmp_code                       ! primary mascon code (PLand, PDeep, PShelf)
  real(kind=8) :: tmp_prim_info(8)               ! array to read lat/lon/rad/area/hgt/density/%land/bit-mapped-tide from mascon_file
  integer*4    :: tmp_nsec,tmp_ntern             ! temp read of number of secondary and ternary mascons in a primary mascon
  integer*4    :: tmp_prim                       ! temp read of a primary mascon number
  integer*4    :: current_nsec                   ! running count of how many secondary mascons have been encountered in mascon_file
  character*15 :: tmp_region                     ! name of region assigned to the primary

! secondary mascon variables
  integer*4    :: tmp_sec                        ! temp read of a secondary mascon number
  character*6  :: tmp_sec_code                   ! secondary mascon code (SLand, SDeep, SShelf)
  integer*4    :: tmp_sec_ntern                  ! temp read of number of secondary and ternary mascons in a primary mascon
  real(kind=8) :: tmp_sec_info(6)                ! array to read lat/lon/rad/area/hgt/density from mascon_file
  integer*4    :: sec2prim                       ! temp read of pointer to primary mascon in which the secondary resides
  integer*4    :: tmp_sec_colour                 ! temp read of colour for secondary mascon

! ternary mascon variables
  integer*4    :: num_tern                       ! running count of how many ternary mascons in mascon_file
  integer*4    :: tmp_tern                       ! temp read of a ternary mascon number
  character*6  :: tmp_tern_code                  ! ternary mascon code (SLand, SDeep, SShelf)
  real(kind=8) :: tmp_tern_info(6)               ! array to read lat/lon/rad/area/hgt/density from mascon_file
  integer*4    :: tern2prim                      ! temp read of pointer to primary mascon in which the ternary resides
  integer*4    :: tern2sec                       ! temp read of pointer to secondary mascon in which the ternary resides
  integer*4    :: tern_colour(2)                 ! prim/sec colours assigned to the ternary mascon (probably not used in graceorb!)
  integer*4    :: tot_tern                       ! total number of ternary mascons

! local variables
  integer*4                 :: ioerr,isec,itern
  character*300             :: message
  real(kind=8)              :: rad_fact

  rad_fact = (4.0*atan(1.0)/180.)       ! conversion factor of pi/180


! the mascon file has lines as follows (with secondary embedded in primary, and ternary embedded in secondary):
!#00000    4581    4581 1485118       1   69390   69390                                                                                                
!# setup by initialize_mascons  20161103 235759.263 +1100                                                                                              
!# modified by classify_mascons  20161103 235900.834 +1100                                                                                             
!# modified by separate_mascons to remove mixed ocean/land primary mascons.  Continental shelf depth: -150.000                                         
!      1  PDeep       1    227   89.0588  185.7386  6356752.3   87393425632.  -4228.0 1029.   0.0     0       region         
!      1  SDeep     227          89.0588  185.7386  6356752.3   87393425632.  -4228.0 1029.     1   317       region         
!      1  TDeep    90.0000    0.0000  6356752.3     269748154.  -4228.0 1029.     1     1   317     0            region
!      2  TDeep    89.8333   60.0000  6356752.5     359663635.  -4219.0 1029.     1     1   317     0            region


! loop through the file until the end of file is reached. Store information as we go ....
  num_mcon = 0
  tot_tern = 0
  current_nsec = 1

  do while (ioerr == 0)
    tmp_region = " "
    read(luin,*,iostat=ioerr,end=1000)tmp_prim,tmp_code,tmp_nsec,tmp_ntern,tmp_prim_info,tmp_region
    if(ioerr == 0 .and. tmp_code(1:1) == "P") then
!     this should be a valid primary mascon line. Check that it doesn't exceed the max number of primary mascons
      if(tmp_prim > max_prim)then
        write(message,'(a,i7,a,i7)')"Input file contains too many primary mascons (",tmp_prim &
                                    ,'). Max dimension in mascon_mod.f90:',max_prim      
        call report_stat('FATAL','LIB','read_mascon_file',mascon_file,message,0)
      endif
      num_mcon = num_mcon + 1
      num_tern = 0                               ! reset to zero the counter of ternary mascons in this primary mascon

      if ( num_mcon .gt. max_prim ) then
        write(message,'(a,i6,a,i6,a)')"Too many mascons (",num_mcon,"). Max number: ",max_prim,"."
        call report_stat('FATAL','LIB','read_mascon_file',' ',message,0)
      endif
!     store the primary mascon information
      mcon_prim(num_mcon,1) = tmp_prim_info(1) * rad_fact    ! latitude of primary mascon
      mcon_prim(num_mcon,2) = tmp_prim_info(2) * rad_fact    ! longitude of primary mascon
      mcon_prim(num_mcon,3) = tmp_prim_info(3)     ! mean radius of primary mascon
      mcon_prim(num_mcon,4) = tmp_prim_info(4)     ! area of primary mascon (as summed up from secondary mascons)
      mcon_prim(num_mcon,5) = tmp_prim_info(5)     ! mean height above sea level
      mcon_prim(num_mcon,6) = tmp_prim_info(6)     ! density of mascon (1000 for continental, 1029 for oceanic
!     pointer information for primary-to-secondary
      mcon_prim(num_mcon,7) = tmp_nsec             ! number of secondary mascons contained within this primary mascon
      mcon_prim(num_mcon,8) = tmp_ntern            ! number of ternary mascons contained within this primary mascon
      mcon_prim(num_mcon,9) = current_nsec         ! (sequential) number of the first secondary mascon in this primary mascon
! bit-mapped tidal information
      mcon_prim(num_mcon,10) = tmp_prim_info(8)    ! bit-mapped tidal amplitude code for primary
! percentage land for the primary mascon
      mcon_prim(num_mcon,11) = tmp_prim_info(7)    ! percentage land of the primary
! 6-char flag for the type of mascon
      prim_flags(num_mcon) = tmp_code
! character region description
      mcon_region(num_mcon)  = tmp_region          ! character*15 region description
!      print*,'imsc,tmp_region',num_mcon," ",mcon_region(num_mcon)
!     increment the number of secondary mascons
      current_nsec = current_nsec + tmp_nsec
    else
      write(message,*)"Error somewhere in primary mascon line: " &
        ,tmp_prim,tmp_code,tmp_nsec,tmp_ntern,tmp_prim_info,tmp_code
      call report_stat('FATAL','LIB','read_mascon_file',' ',message,ioerr)
    endif

! reda the secondary and ternary mascons that comprise this primary mascon. The next line will be a line with info for
! a secondary, followed by one line for each ternary within the secondary. The pattern repeats until tmp_nsec secondary
! mascon lines - and their corresponding ternary mascons - have been read. At that point, the next line should be again
! a primary mascon line.
    do isec = 1,int(mcon_prim(num_mcon,7))
!     read the secondary mascon line information
      read(luin,*,iostat=ioerr,end=1001)tmp_sec,tmp_sec_code,tmp_sec_ntern,tmp_sec_info(1:6),sec2prim,tmp_sec_colour
!print*,"the sec line:",isec,tmp_sec,tmp_sec_code,tmp_sec_ntern,tmp_sec_info(1:6),sec2prim,tmp_sec_colour
      if(ioerr == 0) then
!       this should be a valid secondary mascon line
        if(tmp_sec > max_sec)then
          write(message,'(a,i7,a,i7)')"Input file contains too many secondary mascons (",tmp_sec &
                                    ,'). Max dimension in mascon_mod.f90:',max_sec      
          call report_stat('FATAL','LIB','read_mascon_file',mascon_file,message,0)
        endif
        mcon_sec(num_mcon,isec,1) = tmp_sec_info(1) * rad_fact ! secondary mascon latitude
        mcon_sec(num_mcon,isec,2) = tmp_sec_info(2) * rad_fact ! secondary mascon longitude
        mcon_sec(num_mcon,isec,3) = tmp_sec_info(3)  ! secondary mascon mean radius 
        mcon_sec(num_mcon,isec,4) = tmp_sec_info(4)  ! secondary mascon area (summed from ternary mascons in secondary)
        mcon_sec(num_mcon,isec,5) = tmp_sec_info(5)  ! secondary mascon mean depth/height above sea level
        mcon_sec(num_mcon,isec,6) = tmp_sec_info(6)  ! secondary mascon density
!       pointer information for secondary-to-primary
        mcon_sec(num_mcon,isec,7) = tmp_sec          ! secondary mascon number
        mcon_sec(num_mcon,isec,8) = tmp_sec_ntern    ! number of ternary mascons in this secondary mascon
        mcon_sec_ptr(tmp_sec) = sec2prim             ! pointer to primary mascon in which this secondary resides
        sec_colour(sec2prim) = tmp_sec_colour        ! colour of this secondary mascon
        sec_flags(tmp_sec)   = tmp_sec_code          ! 6-char code for the secondary mascon (SDeep/SLand etc)
      else
        write(message,'(a,i7)')"Error reading  mascon line for secondary mascon",tmp_sec
        call report_stat('FATAL','LIB','read_mascon_file',mascon_file,message,0)
      endif

! now read the ternary mascon information for each ternary contained within this secondary
      do itern=1,int(mcon_sec(num_mcon,isec,8))
        read(luin,*,iostat=ioerr,end=1002)tmp_tern,tmp_tern_code,tmp_tern_info(1:6) &
           ,tern2prim,tern2sec,tern_colour(1),tern_colour(2)
        if(ioerr == 0)then
          if(tmp_tern > max_tern)then
            write(message,'(a,i7,a,i7)')"Input file contains too many ternary mascons (",tmp_tern &
                                      ,'). Max dimension in mascon_mod.f90:',max_tern      
            call report_stat('FATAL','LIB','read_mascon_file',mascon_file,message,0)
          endif
          num_tern = num_tern + 1
          mcon_tern(num_mcon,num_tern,1) = tmp_tern_info(1) * rad_fact ! ternary mascon latitude
          mcon_tern(num_mcon,num_tern,2) = tmp_tern_info(2) * rad_fact ! ternary mascon longitude
          mcon_tern(num_mcon,num_tern,3) = tmp_tern_info(3)  ! ternary mascon radius
          mcon_tern(num_mcon,num_tern,4) = tmp_tern_info(4)  ! ternary mascon area
          mcon_tern(num_mcon,num_tern,5) = tmp_tern_info(5)  ! ternary mascon depth/height above sea level
          mcon_tern(num_mcon,num_tern,6) = tmp_tern_info(6)  ! ternary mascon density
!         pointer information for ternary-to-primary and ternary-to-secondary
          mcon_tern(num_mcon,num_tern,7) = tmp_tern          ! ternary mascon number
          mcon_tern_ptr(tmp_tern,1) = tern2prim              ! pointer to   primary mascon in which this ternary resides
          mcon_tern_ptr(tmp_tern,2) = tern2sec               ! pointer to secondary mascon in which this ternary resides
          tern_colours(tmp_tern,1)  = tern_colour(1)         ! colour of primary mascon in which the ternary resides
          tern_colours(tmp_tern,2)  = tern_colour(2)         ! colour of primary mascon in which the ternary resides
          tern_flag(tmp_tern)       = tmp_tern_code          ! 6-char flag for ternary mascon (TDeep/TLand etc)
        else
          write(message,'(a,i7)')"Error reading  mascon line for ternary mascon",tmp_tern
          call report_stat('FATAL','LIB','read_mascon_file',mascon_file,message,0)
        endif
      enddo  ! end of loop over reading ternary mascons contained within this particular secondary

    enddo  ! end of loop over reading secondary mascon containd within this particular primary

!   increment the total number of ternary mascons
    tot_tern = tot_tern + mcon_prim(num_mcon,8)

  enddo  ! end of generic loop reading through the file (i.e. the loop over "primary mascons" without knowing how many there are in the file)

1000 continue
! store the total number of secondary and primary mascons in the file
  total_sec  = tmp_sec
  total_prim = num_mcon

  write(message,'(a,i7,a)')"Found ",total_prim,"   primary mascons in file "
  call report_stat('STATUS','LIB','read_mascon_file',mascon_file(50:150),message,0)
  write(message,'(a,i7,a)')"Found ",total_sec ," secondary mascons in file "
  call report_stat('STATUS','LIB','read_mascon_file',mascon_file(50:150),message,0)
  write(message,'(a,i7,a)')"Found ",tot_tern,"   ternary mascons in file "
  call report_stat('STATUS','LIB','read_mascon_file',mascon_file(50:150),message,0)

!print*,'subroutine:  mcon_prim(223,:)',mcon_prim(223,:)
!print*,'subroutine: tern_number, mcon_tern_ptr(tern_number,:)',223, mcon_tern_ptr(200:223,:)

! close the mascon_file
  close(luin)
  return

1001 continue
  print*,'must have had a problem reading a secondary mascon line'
  stop

1002 continue
  print*,'must have had a problem reading a ternary mascon line'
  stop


  end subroutine read_mascon_file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine read_ocean_mascons(luin,ocean_mascon_file)

! subroutine to read in the ocean mascon file. This file contains only primary and
! ternary mascons - we think we don't need the secondary mascons. The plan is to:
!
! 1. compute the tidal accelerations on all ternary mascons at all times. We can
!    put this into an OMP loop to make it efficient. We can eliminate the dist_flag/spotlight
!    computations if we always compute on ternary mascons, so we don't need secondary mascons
! 2. Integrate the partials of the ternary mascons so that tidal amplitudes can be
!    estimated on the primary mascons
!
! P. Tregoning
! 12 September 2016

  use mascon_mod

  implicit none

  integer*4, intent(in)    :: luin
  character*150,intent(in) :: ocean_mascon_file

! primary mascon variables
  integer*4    :: num_ocean_mcon                 ! running count of how many primary mascons in mascon_file
  character*6  :: tmp_code                       ! primary mascon code (PLand, PDeep, PShelf)
  real(kind=8) :: tmp_prim_info(6)               ! array to read lat/lon/rad/area/hgt/density from mascon_file
  integer*4    :: tmp_nsec,tmp_ntern             ! temp read of number of secondary and ternary mascons in a primary mascon
  integer*4    :: tmp_prim                       ! temp read of a primary mascon number

! ternary mascon variables
  integer*4    :: tmp_tern                       ! temp read of a ternary mascon number
  character*6  :: tmp_tern_code                  ! ternary mascon code (SLand, SDeep, SShelf)
  real(kind=8) :: tmp_tern_info(6)               ! array to read lat/lon/rad/area/hgt/density from mascon_file
  integer*4    :: tern2prim                      ! temp read of pointer to primary mascon in which the ternary resides
  integer*4    :: tern_colour(2)                 ! prim/sec colours assigned to the ternary mascon (probably not used in graceorb!)
  integer*4    :: tot_ocean_tern                 ! total number of ternary mascons
  integer*4    :: itern


! local variables
  real(kind=8)  :: rad_fact
  integer*4     :: ioerr
  character*250 :: message

  rad_fact = (4.0*atan(1.0)/180.)       ! conversion factor of pi/180

! open the mascon file
  open (unit=luin, file=ocean_mascon_file, status='old',iostat=ioerr)
  if(ioerr /= 0)then
    call report_stat('FATAL','GRACEORB','read_ocean_mascon_file',ocean_mascon_file &
                       ,'Error opening mascon file. Does it exist?',0)
  else
    call report_stat('STATUS','GRACEORB','read_ocean_mascon_file',ocean_mascon_file,'Reading ocean mascon information',0)
  endif

! loop through the file until the end of file is reached. Store information as we go ....
  total_ocean_tern = 0

  do while (ioerr == 0)
    read(luin,*,iostat=ioerr,end=1000)tmp_prim,tmp_code,tmp_nsec,tmp_ntern
    if(ioerr == 0 .and. tmp_code(1:1) == "P") then
!     this should be a valid primary mascon line. tmp_ntern is how many ternary ocean mascons in this primary ocean mascon.
      num_ocean_mcon = tmp_prim
      mcon_ocean_prim(tmp_prim,1) = tmp_ntern
    else
      write(message,*)"Error somewhere in primary mascon line: " &
        ,tmp_prim,tmp_code,tmp_nsec,tmp_ntern,tmp_prim_info,tmp_code
      call report_stat('FATAL','GRACEORB','read_mascon_file',' ',message,0)
    endif

! read in the ternary ocean mascons
    do itern=1,tmp_ntern
      read(luin,*,iostat=ioerr,end=1002)tmp_tern,tmp_tern_code,tmp_tern_info(1:6),tern2prim
      if(ioerr == 0)then
        if(tmp_tern > max_tern)then
          write(message,'(a,i7,a,i7)')"Input file contains too many ocean ternary mascons (",tmp_tern &
                                    ,'). Max dimension in mascon_mod.f90:',max_tern      
          call report_stat('FATAL','GRACEORB','read_mascon_file',ocean_mascon_file,message,0)
        endif
        total_ocean_tern = total_ocean_tern + 1
        mcon_ocean_tern(total_ocean_tern,1) = tmp_tern_info(1) * rad_fact ! ternary mascon latitude
        mcon_ocean_tern(total_ocean_tern,2) = tmp_tern_info(2) * rad_fact ! ternary mascon longitude
        mcon_ocean_tern(total_ocean_tern,3) = tmp_tern_info(3)            ! ternary mascon radius
        mcon_ocean_tern(total_ocean_tern,4) = tmp_tern_info(4)            ! ternary mascon area
        mcon_ocean_tern(total_ocean_tern,5) = tmp_tern_info(5)            ! ternary mascon depth/height above sea level
        mcon_ocean_tern(total_ocean_tern,6) = tmp_tern_info(6)            ! ternary mascon density
!       pointer information for ternary-to-primary and ternary-to-secondary
        mcon_ocean_tern_ptr(tmp_tern,1)   = tern2prim         ! pointer to   primary mascon in which this ternary resides
        mcon_ocean_tern_ptr(tmp_tern,2)   = total_ocean_tern  ! row is ternary mascon number, value is sequential ocean mascon number.
                                                              ! we use this to get tide height at satellite location for debug output

      else
        write(message,'(a,i7)')"Error reading  mascon line for ocean ternary mascon",tmp_tern
        call report_stat('FATAL','GRACEORB','read_mascon_file',ocean_mascon_file,message,0)
      endif
    enddo  ! end of loop over reading ternary mascons contained within this particular secondary
  enddo

1000 continue
! store the total number of secondary and primary mascons in the file
  total_ocean_prim = num_ocean_mcon

  write(message,'(a,i7,a)')"Found ",total_ocean_prim,"   primary ocean mascons in file "
  call report_stat('STATUS','GRACEORB','read_mascon_file',ocean_mascon_file(50:150),message,0)
  write(message,'(a,i7,a)')"Found ",total_ocean_tern,"   ternary ocean mascons in file "
  call report_stat('STATUS','GRACEORB','read_mascon_file',ocean_mascon_file(50:150),message,0)
  return


1002 continue
  print*,'must have had a problem reading a ternary ocean mascon line'
  stop



  end subroutine read_ocean_mascons
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine write_mascon_record(luout,msc_code,msc_num,nsec,ntern,msc_crds,msc_area,msc_depth,msc_density &
                                ,percent_land,tide_flag,region,pointers,colours)

! subroutine to write out a primary, secondary or ternary mascon record (ascii)
! to a mascon file. This will standardise the file format across all the mascon
! programs
!
! P. Tregoning
! 9 November 2016

  implicit none

  integer*4,   intent(in) :: luout                ! unit number of output file to which the mascon line will be written
  character*6, intent(in) :: msc_code             ! "PDeep ", "SLand ", "TShelf", "TCasp ", "PEyre ", etc
  integer*4,   intent(in) :: msc_num              ! the number of the actual mascon to be written out
  integer*4,   intent(in) :: nsec,ntern           ! the number of secondary and/or ternary mascons in this actual mascon
  real(kind=8),intent(in) :: msc_crds(3)          ! the mascon coords (lat, lon, radius)
  real(kind=8),intent(in) :: msc_area,msc_depth,msc_density,percent_land  ! mascon attribute values
  integer*4,   intent(in) :: tide_flag            ! bit-mapped flag for tidal amplitude estimation
  character*15,intent(in) :: region               ! name of region to which mascon relates
  integer*4,   intent(in) :: pointers(2)          ! tern2prim, tern2sec, sec2prim pointers
  integer*4,   intent(in) :: colours(2)           ! up to two colours to assign to the mascon


! primary mascon line
  if(msc_code(1:1) == "P")then
    write(luout,'(i7,2x,a6,2i7,2f10.4,f11.1,f15.0,f9.1,f6.0,f6.1,i6,2x,a20)')  &
           msc_num,msc_code,nsec,ntern,msc_crds,msc_area,msc_depth,msc_density,percent_land,tide_flag,region
 
! secondary mascon
  else if(msc_code(1:1) == "S")then
    write(luout,'(i7,2x,a6,i7,7x,2f10.4,f11.1,f15.0,f9.1,f6.0,2i6,2x,a20)')   &
           msc_num,msc_code,ntern,msc_crds,msc_area,msc_depth,msc_density,pointers(1),colours(1),region

! ternary mascon
  elseif(msc_code(1:1) == "T")then
    write(luout,'(i7,2x,a6,2f10.4,f11.1,f15.0,f9.1,f6.0,4i6,9x,a6)')  &
           msc_num,msc_code,msc_crds,msc_area,msc_depth,msc_density,pointers,colours,region

  endif

 
  end subroutine write_mascon_record
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine calc_mascon_xyz(use_ocean_mascons)

! subroutine to convert the input mascon lat/lon/rad into cartesian XYZ
!
! P. Tregoning
! 7 September 2016

  use mascon_mod

  implicit none

  character*1, intent(in) :: use_ocean_mascons
  integer*4               :: iprim,isec,itern
  real(kind=8)            :: tmp_xyz(3)

  do iprim=1,total_prim
! primary mascons
    tmp_xyz(1) = mcon_prim(iprim,3)*cos(mcon_prim(iprim,1))*cos(mcon_prim(iprim,2))
    tmp_xyz(2) = mcon_prim(iprim,3)*cos(mcon_prim(iprim,1))*sin(mcon_prim(iprim,2))
    tmp_xyz(3) = mcon_prim(iprim,3)*sin(mcon_prim(iprim,1))
!   and replace the values of mcon_prim with the computed XYZ values
    mcon_prim(iprim,1:3) = tmp_xyz(1:3)
! secondary mascons
    do isec = 1,int(mcon_prim(iprim,7))
      tmp_xyz(1) = mcon_sec(iprim,isec,3)*cos(mcon_sec(iprim,isec,1))*cos(mcon_sec(iprim,isec,2))
      tmp_xyz(2) = mcon_sec(iprim,isec,3)*cos(mcon_sec(iprim,isec,1))*sin(mcon_sec(iprim,isec,2))
      tmp_xyz(3) = mcon_sec(iprim,isec,3)*sin(mcon_sec(iprim,isec,1))
!     and replace the values of mcon_prim with the computed XYZ values
      mcon_sec(iprim,isec,1:3) = tmp_xyz(1:3)
    enddo

! ternary mascons
    do itern=1,int(mcon_prim(iprim,8))
      tmp_xyz(1) = mcon_tern(iprim,itern,3)*cos(mcon_tern(iprim,itern,1))*cos(mcon_tern(iprim,itern,2))
      tmp_xyz(2) = mcon_tern(iprim,itern,3)*cos(mcon_tern(iprim,itern,1))*sin(mcon_tern(iprim,itern,2))
      tmp_xyz(3) = mcon_tern(iprim,itern,3)*sin(mcon_tern(iprim,itern,1))
!     and replace the values of mcon_prim with the computed XYZ values
      mcon_tern(iprim,itern,1:3) = tmp_xyz(1:3)
    enddo

  enddo
  call report_stat('STATUS','GRACEORB','calc_mascon_xyz',' '," Converted all mascons lat/lon/rad into e-fixed XYZ",0)

! check whether there are ternary ocean mascons to convert as well
  if(use_ocean_mascons == "G")then    ! "G" means we are representing the tides on a grid (not as spherical harmonics)
! ternary mascons
    do itern=1,total_ocean_tern
        tmp_xyz(1) = mcon_ocean_tern(itern,3)*cos(mcon_ocean_tern(itern,1))*cos(mcon_ocean_tern(itern,2))
        tmp_xyz(2) = mcon_ocean_tern(itern,3)*cos(mcon_ocean_tern(itern,1))*sin(mcon_ocean_tern(itern,2))
        tmp_xyz(3) = mcon_ocean_tern(itern,3)*sin(mcon_ocean_tern(itern,1))
!       and replace the values of mcon_prim with the computed XYZ values
        mcon_ocean_tern(itern,1:3) = tmp_xyz(1:3)
    enddo
    call report_stat('STATUS','GRACEORB','calc_mascon_xyz',''&
                      ," Converted all ternary ocean mascons lat/lon/rad into e-fixed XYZ",0)
  endif



  return
  end subroutine calc_mascon_xyz
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine msc_in_region(shift_polygon,lat,lon,poly_lat,poly_lon,npoints,in_or_out)     

! subroutine to determine whether a primary mascon resides within a particular region
! as defined by a polygon of lat/lon coordinates
!
! P. Tregoning
! 11 November 2016

  implicit none

  logical,       intent(in)    :: shift_polygon                       ! indicates whether the polygon was shifted east by 90 deg so that it doesn't cross 0E
  real(kind=8),  intent(in)    :: lat,lon                             ! coordinates of point
  integer*4,     intent(in)    :: npoints                             ! number of vertices of the polygon (first point is not repeated)
  real(kind=8),  intent(inout) :: poly_lat(npoints),poly_lon(npoints) ! coords of vertices of polygon describing region   
  integer*4,     intent(out)   :: in_or_out                           ! -1 if point inside the polygon, 0 if on an edge, 1 otherwise 

! local variables
  integer*4  :: i,j
  real(kind=8),allocatable   :: tmplat(:),tmplon(:)
  real(kind=8) :: temp_lon
  LOGICAL MX,MY,NX,NY                                               

  allocate(tmplat(npoints))
  allocate(tmplon(npoints))

! PT161118: do we need to shift the point's longitude by 90 deg?
  temp_lon = lon
  if(shift_polygon)temp_lon = temp_lon + 90.d0
  if(temp_lon > 360.d0)temp_lon = temp_lon - 360.d0

  do i=1,npoints
    tmplat(i) = poly_lat(i)-lat
    tmplon(i) = poly_lon(i)-temp_lon
  enddo

  in_or_out = -1
  do i=1,npoints
    j=1+mod(i,npoints)

      MX=tmplat(I).GE.0.0                                                    
      NX=tmplat(J).GE.0.0                                                    
      MY=tmplon(I).GE.0.0                                                    
      NY=tmplon(J).GE.0.0                                                    
      IF(.NOT.((MY.OR.NY).AND.(MX.OR.NX)).OR.(MX.AND.NX)) GO TO 2       
      IF(.NOT.(MY.AND.NY.AND.(MX.OR.NX).AND..NOT.(MX.AND.NX))) GO TO 3  
      in_or_out=-in_or_out                                                      
      GO TO 2                                                           
3     IF((tmplon(I)*tmplat(J)-tmplat(I)*tmplon(J))/(tmplat(J)-tmplat(I))) 2,4,5                       
4     in_or_out=0                                                           
      RETURN                                                            
5     in_or_out=-in_or_out                                                      


2  enddo

  deallocate(tmplat)
  deallocate(tmplon)
  return
  end subroutine msc_in_region
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine hash_header(headrec,nhr,hashcode)

! generates a hashcode from the supplied header lines
!
!    headrec: array of header records to be hashed
!    nhr: number of header records
!    hashcode: 7 digit CRC checksum prefixed with "#"
!     - trailing blanks in header lines are ignored
!     - uses linux cksum function implementing ISO/IEC 8802-3:1989
!     - ten digit decimal hashcode compressed to base36
!
! H. McQueen
! 15 November 2016

   implicit none

    integer i,nhr,lun
    integer (kind=8) n
    integer m,rem,base
    character*12 hashcode
    character(150), dimension(1:nhr)    :: headrec
    character*1, dimension(1:12)   ::chr

    lun=99
    open(lun,file="headcheck",status="unknown")
    write(lun,'(a120)') (trim(headrec(i)),i=1,nhr)
    close(lun)

    call system("cksum headcheck|awk '{print $1}' >checksum")
    open(lun,file="checksum",status="old")
    read(lun,'(a12)') hashcode
    close(lun)

! convert hashcode to base36

    read(hashcode,*) n
    base=36
    i=0
    do while(n.gt.0)
        m=n/base
        rem=n-m*base
        n=m
        i=i+1
        if(rem.le.9) then
            chr(i)=char(rem+48)
        else
            chr(i)=char(rem+55)
            endif
        enddo
    n=i+1
    do i=1,n-1
        hashcode(i:i)=chr(n-i)
        enddo
    do i=n,12
        hashcode(i:i)=" "
        enddo


    hashcode="#"//hashcode

return
end

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine get_random_value(rand_numbers,nvals,rand_number)

! subroutine to get a random value and check that it hasn't been selected previously

  implicit none

! passed variables
  integer*4, intent(in)     :: nvals
  logical  , intent(inout)  :: rand_numbers(nvals)
  integer*4, intent(out)    :: rand_number

! local variables
  real(kind=8) :: tmp_rand
  logical   :: found 
  integer*4 :: i
  found = .false.
  call srand(nvals)

  do while (.not. found)
    tmp_rand = rand(0)
    rand_number = int(tmp_rand*nvals)+1
!print*,'rand(0),nvals,rand(0)*nvals',tmp_rand,nvals,tmp_rand*nvals,rand_number
    if(.not. rand_numbers(rand_number))then
      rand_numbers(rand_number) = .true.
      found = .true.
    endif

! debug
!    do i=1,nvals
!      print*,'i, T/F: ',i,rand_numbers(i), rand_number,rand_number*nvals
!    enddo

  enddo

  end subroutine get_random_value
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!







