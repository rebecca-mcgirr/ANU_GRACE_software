#!/bin/csh -f

# script to plot a time series of the difference between positions and velocities of two GTORB files
#
# P. Tregoning
# 15 November 2013
#
# MODS
# PT140515: changed the way the partials are plotted to match the mods to gracediff, so that pos/vel partials wrt any param (XYZ, velXYZ, bias, scale) can be plotted.
#
# SA 170616: removed the offset of sat B.... Don't know why it was in!
gmt gmtset FONT_TITLE 10    >& /dev/null
gmt gmtset FONT_LABEL   15  >& /dev/null
gmt gmtset PAPER_MEDIA a4+  >& /dev/null

set version = ~/gt

if ($#argv == 0) then
  echo "sh_plot_GTORB_diff -sat A/B -t GTORB_2010-09-11_00-00-00_A_02.bin.temporal GTORB_2010-09-11_00-00-00_A_02.bin.truth -yr 0.5 [yrange and anot]-x xmin xmax -out ACR/NEU -y_X etc -yvel_X etc -yanot_X etc -xanot 100f20 -partial [X/Y/Z/Xdot/Ydot/Zdot/Bsx/Bsy/Bsz/Sclx/Scly/Sclz or N]"
  exit
endif

# set default values
set xmin = 0
set xmax = 18000
set xanot = "2000f500"
# positions
set ymin_X = -1
set ymax_X =  1
set ymin_Y = -1
set ymax_Y = 1
set ymin_Z = -1
set ymax_Z = 1
set yanot_X = "1f.25"
set yanot_Y = "1f.25"
set yanot_Z = "1f.25"

# velocities
set yvelmin_X = -1
set yvelmax_X =  1
set yvelmin_Y = -1
set yvelmax_Y =  1
set yvelmin_Z = -1
set yvelmax_Z =  1
set yvelanot_X = "1f0.5"
set yvelanot_Y = "1f0.5"
set yvelanot_Z = "1f0.5"

# KBRR
set ymin_kbrr = -10
set ymax_kbrr =  10
set yanot_kbrr = 4f2

# output type
set out_type = "XYZ"  # ACR for along/cross/rad or NEU for north/east/up or XYZ

set prefit_file = "none"

# satellite
set sat = "A"

# plot X-position partials ?
set partial = "N"
set ypartmin_X = -2000
set ypartmax_X =  2000
set ypartmin_Y = -60
set ypartmax_Y =  60
set ypartmin_Z = -60
set ypartmax_Z =  60
set ypartmin_velX = -2000
set ypartmax_velX =  2000
set ypartmin_velY = -60
set ypartmax_velY =  60
set ypartmin_velZ = -60
set ypartmax_velZ =  60
set yanot_Xpart = 1000f500
set yanot_Ypart = 30f30
set ypartmin_all = -60
set ypartmax_all =  60
set part_text = " "
set sat_offset = 0
set reverse = 1.0

# colours
#set part_colour = "139/69/19"
set part_colour = "34/139/34"
set prefit_colour = "255/215/0"

# the "true" adjustment (for debug with the partials)
set true_adj = 0

##################### DECIPHER COMMAND LINE #######################
while ($#argv > 0 )
  set input = ( $argv )
  switch($input[1])
    case -t:
      set orbfile1 = $input[2] ; shift argv  
      set orbfile2 = $input[3] ; shift argv
    breaksw
# x-axis
    case -x:
      set xmin = $input[2] ; shift argv  
      set xmax = $input[3] ; shift argv
    breaksw
    case -xanot:
      set xanot = $input[2]
    breaksw
# output type
    case -out:
      set out_type = $input[2] ; shift argv  
    breaksw
# satellite
    case -sat:
      set sat = $input[2] ; shift argv  
    breaksw
# overlay prefit residual file
    case -prefit:
      set prefit_file = $input[2] ; shift argv  
    breaksw
# reverse sign of prefit residuals
    case -reverse:
      set reverse = -1.0  
    breaksw
# positions
    case -y_all:
      set ymin_X = $input[2] ; shift argv
      set ymax_X = $input[3] ; shift argv
      set ymin_Y = $ymin_X
      set ymax_Y = $ymax_X
      set ymin_Z = $ymin_X
      set ymax_Z = $ymax_X
      set yvelmin_X = $ymin_X
      set yvelmax_X = $ymax_X
      set yvelmin_Y = $ymin_X
      set yvelmax_Y = $ymax_X
      set yvelmin_Z = $ymin_X
      set yvelmax_Z = $ymax_X
    breaksw
    case -yanot_all:
      echo "Setting all Y-axes annotations"
      set yanot_X = $input[2] ; shift argv
      set yanot_Y = $yanot_X
      set yanot_Z = $yanot_X
      set yvelanot_X = $yanot_X
      set yvelanot_Y = $yanot_X
      set yvelanot_Z = $yanot_X
    breaksw
    case -yr:
      set ymin_X = $input[2] ; shift argv
      set ymax_X = $ymin_X 
      set ymin_X = `echo $ymin_X | awk '{print -1 * $1}'`
      set ymin_Y = $ymin_X
      set ymax_Y = $ymax_X
      set ymin_Z = $ymin_X
      set ymax_Z = $ymax_X
      set yvelmin_X = $ymin_X
      set yvelmax_X = $ymax_X
      set yvelmin_Y = $ymin_X
      set yvelmax_Y = $ymax_X
      set yvelmin_Z = $ymin_X
      set yvelmax_Z = $ymax_X
#     now the annotations to the same value
      set yanot_X = $ymax_X
      set yanot_Y = $yanot_X
      set yanot_Z = $yanot_X
      set yvelanot_X = $yanot_X
      set yvelanot_Y = $yanot_X
      set yvelanot_Z = $yanot_X
    breaksw

    case -y_X:
      set ymin_X = $input[2] ; shift argv  
      set ymax_X = $input[3] ; shift argv
    breaksw
    case -y_Y:
      set ymin_Y = $input[2] ; shift argv  
      set ymax_Y = $input[3] ; shift argv
    breaksw
    case -y_Z:
      set ymin_Z = $input[2] ; shift argv  
      set ymax_Z = $input[3] ; shift argv
    breaksw
    case -yanot_X:
      set yanot_X = $input[2]
    breaksw
    case -yanot_Y:
      set yanot_Y = $input[2]
    breaksw
    case -yanot_Z:
      set yanot_Z = $input[2]
    breaksw
# velocities
    case -yvel_X:
      set yvelmin_X = $input[2] ; shift argv  
      set yvelmax_X = $input[3] ; shift argv
    breaksw
    case -yvel_Y:
      set yvelmin_Y = $input[2] ; shift argv  
      set yvelmax_Y = $input[3] ; shift argv
    breaksw
    case -yvel_Z:
      set yvelmin_Z = $input[2] ; shift argv  
      set yvelmax_Z = $input[3] ; shift argv
    breaksw
    case -yvelanot_X:
      set yvelanot_X = $input[2] ; shift argv
    breaksw
    case -yvelanot_Y:
      set yvelanot_Y = $input[2] ; shift argv
    breaksw
    case -yvelanot_Z:
      set yvelanot_Z = $input[2] ; shift argv
    breaksw
    case -xanot:
      set xanot = $input[2] ; shift argv
    breaksw
# kbrr axes
    case -y_kbrr:
      set ymin_kbrr = $input[2] ; shift argv  
      set ymax_kbrr = $input[3] ; shift argv
    breaksw
    case -yanot_kbrr:
      set yanot_kbrr = $input[2] ; shift argv
    breaksw    
# X-position partials?
    case -partial:
      set partial = $input[2] ; shift argv
    breaksw    
    case -ypart_X:
      set ypartmin_X = $input[2] ; shift argv  
      set ypartmax_X = $input[3] ; shift argv
    breaksw
    case -ypart_Y:
      set ypartmin_Y = $input[2] ; shift argv  
      set ypartmax_Y = $input[3] ; shift argv
    breaksw
    case -ypart_Z:
      set ypartmin_Z = $input[2] ; shift argv  
      set ypartmax_Z = $input[3] ; shift argv
    breaksw
    case -ypart_velX:
      set ypartmin_velX = $input[2] ; shift argv  
      set ypartmax_velX = $input[3] ; shift argv
    breaksw
    case -ypart_velY:
      set ypartmin_velY = $input[2] ; shift argv  
      set ypartmax_velY = $input[3] ; shift argv
    breaksw
    case -ypart_velZ:
      set ypartmin_velZ = $input[2] ; shift argv  
      set ypartmax_velZ = $input[3] ; shift argv
    breaksw
    case -ypart_all:
      set ypartmin_X = $input[2] ; shift argv  
      set ypartmax_X = $input[3] ; shift argv
      set ypartmin_Y = $ypartmin_X  
      set ypartmax_Y = $ypartmax_X
      set ypartmin_Z = $ypartmin_X  
      set ypartmax_Z = $ypartmax_X
      set ypartmin_velX = $ypartmin_X  
      set ypartmax_velX = $ypartmax_X
      set ypartmin_velY = $ypartmin_X  
      set ypartmax_velY = $ypartmax_X
      set ypartmin_velZ = $ypartmin_X  
      set ypartmax_velZ = $ypartmax_X
      set yanot_Ypart = $yanot_Xpart
    breaksw
    case -yanot_Xpart:
      set yanot_Xpart = $input[2] ; shift argv  
    breaksw
! the "true" adjustment
    case -true_adj:
      set true_adj = $input[2] ; shift argv  
    breaksw
 endsw
  if ( $#argv > 0 ) shift argv
end
alldone:
######################################################################
echo sh_plot_GTORB_diff $orbfile1 $orbfile2 $sat $out_type
set outfile = GTORB_diff_${sat}.ps

# set the output labels
if ($out_type == "ACR")then
  set ylabel = ("A/Track" "C/Track" "Radial" )
else if ($out_type == "NEU") then
  set ylabel = ("North"  "East" "Up")
else
  set ylabel = ("X" "Y" "Z")
endif

# set the satellite offset for extracting residuals and partials for GRACE B
if ($sat == "B")set sat_offset = 0

# generate the differences 
echo ${version}/gracefit/gracediff $orbfile1 $orbfile2 $xmax $partial
${version}/gracefit/gracediff $orbfile1 $orbfile2 $xmax $partial > gracediff.out

# generate the position/velocity difference file
cat gracediff.out | grep "Pos/Vel"   > posvel.out
awk '{print $1,  $3 + '$sat_offset'}' posvel.out > pos.dX
awk '{print $1, $4 + '$sat_offset'}' posvel.out > pos.dY
awk '{print $1, $5 + '$sat_offset'}' posvel.out > pos.dZ
awk '{print $1, $6 + '$sat_offset'}' posvel.out > pos.dXdot
awk '{print $1, $7 + '$sat_offset'}' posvel.out > pos.dYdot
awk '{print $1, $8 + '$sat_offset'}' posvel.out > pos.dZdot

# PT140407: extract information regarding the X-position partial if required
if ($partial != "N") then
  \rm gracediff.partial >& /dev/null
  cat gracediff.out | grep "Partial" > gracediff.partial
  awk '{print $3,  $4 + '$sat_offset'        }' gracediff.partial > part.dXd$partial
  awk '{print $3,  $5 + '$sat_offset'        }' gracediff.partial > part.dYd$partial
  awk '{print $3,  $6 + '$sat_offset'        }' gracediff.partial > part.dZd$partial
  awk '{print $3, ($7 + '$sat_offset') * 1   }' gracediff.partial > part.dXdotd$partial          #'
  awk '{print $3, ($8 + '$sat_offset') * 1   }' gracediff.partial > part.dYdotd$partial          #'
  awk '{print $3, ($9 + '$sat_offset') * 1   }' gracediff.partial > part.dZdotd$partial          #'
endif

# PT140516: generate a file of prefit_resid/partial for each dP/drequested. This should be the estimate of the adjustment to the parameter that will reconcile the partial and the prefit residual
\rm adj_d$partial'.estimate' >& /dev/null ; touch adj_d$partial'.estimate'
if ($partial != "N")then
  foreach component (dX dY dZ dXdot dYdot dZdot )
    paste pos.$component part.${component}d${partial} | awk '{printf "%8d %10.8f \n", $1, $2 / $4}' > adj_est.$component
  end 
# then put them all together
  paste adj_est.dX adj_est.dY adj_est.dZ adj_est.dXdot adj_est.dYdot adj_est.dZdot | awk '{if (NR < 8810) {printf "%8d %10.5f  %10.5f  %10.5f  %10.5f  %10.5f  %10.5f \n",  $1 , $2 * 1000, $4 * 1000, $6 * 1000, $8, $10, $12}}' > adj_d${partial}.estimate
endif

# if requested - and output type is XYZ - overlay the prefit residuals from the input file
if ($prefit_file != "none" && $out_type == "XYZ" && $sat == "A")then
  echo "Extracting GRACE "$sat "prefit pos/vel residuals from file " $prefit_file
#  tail -n+7 $kb_file | awk '{if ($13 != 0.0 && $14 != 0.0) {print $1, $13, $14, $15, $16, $17, $18}}' > gracefit.out
  tail -n+3 $prefit_file | awk '{print $1, $5 * '$reverse', $6 * '$reverse', $7 * '$reverse', $8 * '$reverse', $9 * '$reverse', $10 * '$reverse', $11 * '$reverse', $12 * '$reverse', $13 * '$reverse', $14 * '$reverse', $15 * '$reverse', $16 * '$reverse'}' > gracefit.out
  awk '{print $1, $2}' gracefit.out > prefit_pos.dX
  awk '{print $1, $3}' gracefit.out > prefit_pos.dY
  awk '{print $1, $4}' gracefit.out > prefit_pos.dZ
  awk '{print $1, $5 }' gracefit.out > prefit_vel.dXdot
  awk '{print $1, $6 }' gracefit.out > prefit_vel.dYdot
  awk '{print $1, $7 }' gracefit.out > prefit_vel.dZdot
else if ($prefit_file != "none" && $out_type == "XYZ" && $sat == "B")then
  echo "Extracting GRACE "$sat "prefit pos/vel residuals from file " $prefit_file
#  tail -n+7 $kb_file | awk '{if ($13 != 0.0 && $14 != 0.0) {print $1, $13, $14, $15, $16, $17, $18}}' > gracefit.out
  tail -n+2 $prefit_file | awk '{print $1,  $11 * '$reverse', $12 * '$reverse', $13 * '$reverse', $14 * '$reverse', $15 * '$reverse', $16 * '$reverse'}' > gracefit.out
  awk '{print $1, $2}' gracefit.out > prefit_pos.dX
  awk '{print $1, $3}' gracefit.out > prefit_pos.dY
  awk '{print $1, $4}' gracefit.out > prefit_pos.dZ
  awk '{print $1, $5 }' gracefit.out > prefit_vel.dXdot
  awk '{print $1, $6 }' gracefit.out > prefit_vel.dYdot
  awk '{print $1, $7 }' gracefit.out > prefit_vel.dZdot
endif

set dy = "-4.1"

# reset the axes depending on whether the partial is Bsx or Bsy/Bsz
if ($partial == "Bsx")then
  set ypartmin_Y = -2000
  set ypartmax_Y =  2000
  set yanot_Ypart = 1000f500
else if ($partial == "Bsy" || $partial == "Bsz" ) then
  set ypartmin_X = -60
  set ypartmax_X =  60
  set yanot_Xpart = 30f30
endif  

# plot the position along/cross/radial
set plotsize = "15/3.5"
gmt psxy pos.dX -JX$plotsize -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_X}:"Pos $ylabel[1] (m)"::."$orbfile1 vs $orbfile2":nesW -Wthick,0/0/255 -X3.5 -Y24.2 -K -P >! $outfile
if ($prefit_file != "none" && $out_type == "XYZ")gmt psxy prefit_pos.dX -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba1${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy prefit-adj_times_d${partial}.dX -JX$plotsize -R$xmin/$xmax/$ymin_X/$ymax_X -Wthick,200/100/20 -O -K >> $outfile
if($partial != "N")gmt psxy part.dXd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_X/$ypartmax_X -Ba1${xanot}/${yanot_Xpart}:"dX/d$partial ":nEsw -Wthick,$part_colour -O -K >> $outfile

gmt psxy pos.dY -JX$plotsize  -R$xmin/$xmax/$ymin_Y/$ymax_Y -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesW -Wthick,0/0/255 -Y$dy -O -K >> $outfile
if ($prefit_file != "none" && $out_type == "XYZ")gmt psxy prefit_pos.dY -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy part.dYd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_Y/$ypartmax_Y -Ba1${xanot}/${yanot_Ypart}:"dY/d$partial":nEsw -Wthick,$part_colour -O -K >> $outfile

gmt psxy pos.dZ -JX$plotsize  -R$xmin/$xmax/$ymin_Z/$ymax_Z -Ba${xanot}/${yanot_Z}:"Pos $ylabel[3]  (m)":nesW -Wthick,0/0/255 -Y$dy -O -K >> $outfile
if ($prefit_file != "none" && $out_type == "XYZ")gmt psxy prefit_pos.dZ -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy part.dZd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_Z/$ypartmax_Z -Ba1${xanot}/${yanot_Ypart}:"dZ/d$partial":nEsw -Wthick,$part_colour -O -K >> $outfile

# plot the velocity along/cross/radial
gmt psxy pos.dXdot -JX$plotsize  -R$xmin/$xmax/$yvelmin_X/$yvelmax_X -Ba${xanot}/${yvelanot_X}:"Vel $ylabel[1] (mm/s)":nesW -Wthick,0/0/255 -Y$dy   -O -K >> $outfile
if ($prefit_file != "none" && $out_type == "XYZ")gmt psxy prefit_vel.dXdot -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy part.dXdotd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_velX/$ypartmax_velX -Ba1${xanot}/${yanot_Ypart}:"dXdot/d$partial":nEsw --Wthick,$part_colour -O -K >> $outfile

gmt psxy pos.dYdot -JX$plotsize  -R$xmin/$xmax/$yvelmin_Y/$yvelmax_Y -Ba${xanot}/${yvelanot_Y}:"Vel $ylabel[2] (mm/s)":nesW -Wthick,0/0/255 -Y$dy -O -K >> $outfile
if ($prefit_file != "none" && $out_type == "XYZ")gmt psxy prefit_vel.dYdot -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy part.dYdotd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_velY/$ypartmax_velY -Ba1${xanot}/${yanot_Ypart}:"dYdot/d$partial":nEsw --Wthick,$part_colour -O -K >> $outfile

gmt psxy pos.dZdot -JX$plotsize  -R$xmin/$xmax/$yvelmin_Z/$yvelmax_Z -Ba${xanot}:"Epoch":/${yvelanot_Z}:"Vel $ylabel[3]  (mm/s)":neSW -Wthick,0/0/255 -Y$dy -O -K >> $outfile
if ($prefit_file != "none" && $out_type == "XYZ" || $partial != "N" )gmt psxy prefit_vel.dZdot -JX$plotsize  -R$xmin/$xmax/$ymin_X/$ymax_X -Ba${xanot}/${yanot_Y}:"Pos $ylabel[2] (m)":nesw -Wthick,255/0/0 -O -K >> $outfile
if($partial != "N")gmt psxy part.dZdotd$partial -JX$plotsize -R$xmin/$xmax/$ypartmin_velZ/$ypartmax_velZ -Ba1${xanot}/${yanot_Ypart}:"dZdot/d$partial":nEsw -Wthick,$part_colour -O -K >> $outfile

# plot the kbrr prefit
if ($prefit_file != "none" )gmt psxy $prefit_file -JX$plotsize -R$xmin/$xmax/$ymin_kbrr/$ymax_kbrr -Ba${xanot}/${yanot_kbrr}:"KBRR prefit (um/s)":neSW -Wthick,255/0/255 -Y$dy   -O -K >> $outfile

gs $outfile


